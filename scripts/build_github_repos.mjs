import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const reposConfigPath = path.join(__dirname, '../public/assets/data/repos.config.json');
const outputPath = path.join(__dirname, '../public/assets/data/github-repos.generated.json');

function loadExistingRepos() {
  // Prefer keeping existing values when GitHub API has transient failures (e.g. 504s).
  // This prevents us from wiping descriptions/stars/language to blank/0.
  try {
    if (fs.existsSync(outputPath)) {
      const data = JSON.parse(fs.readFileSync(outputPath, 'utf-8'));
      if (Array.isArray(data) && data.length) return data;
    }
  } catch {
    // ignore
  }
  return [];
}

function githubOpenGraphThumbnail(owner, repo) {
  // Public OpenGraph image generated by GitHub for the repo.
  // The leading path segment is a cache-buster token; any string is accepted.
  return `https://opengraph.githubassets.com/1/${owner}/${repo}`;
}

async function fetchRepoDataOnce(owner, repo) {
  const headers = {
    Accept: 'application/vnd.github+json',
    'User-Agent': 'saharmor.github.io build script',
  };
  if (process.env.GITHUB_TOKEN) {
    headers.Authorization = `Bearer ${process.env.GITHUB_TOKEN}`;
  }

  const response = await fetch(`https://api.github.com/repos/${owner}/${repo}`, { headers });
  if (!response.ok) {
    const err = new Error(`GitHub API error: ${response.status} ${response.statusText}`);
    err.status = response.status;
    throw err;
  }

  const data = await response.json();
  return {
    name: data.name,
    fullName: data.full_name,
    description: data.description || '',
    stars: data.stargazers_count || 0,
    url: data.html_url,
    homepage: data.homepage || null,
    language: data.language || null,
    updatedAt: data.updated_at,
    pushedAt: data.pushed_at,
  };
}

async function fetchRepoDataWithRetries(owner, repo, { maxAttempts = 4 } = {}) {
  let lastError = null;
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fetchRepoDataOnce(owner, repo);
    } catch (error) {
      lastError = error;
      const status = error?.status;
      const isRetryable = status === 502 || status === 503 || status === 504;
      if (!isRetryable || attempt === maxAttempts) break;

      const delayMs = 400 * Math.pow(2, attempt - 1);
      console.warn(`Retrying ${owner}/${repo} after ${status} (attempt ${attempt}/${maxAttempts}, waiting ${delayMs}ms)...`);
      await new Promise((resolve) => setTimeout(resolve, delayMs));
    }
  }
  throw lastError;
}

async function build() {
  console.log('Building GitHub repos data...');
  
  const reposConfig = JSON.parse(fs.readFileSync(reposConfigPath, 'utf-8'));
  const existingRepos = loadExistingRepos();
  const existingByFullName = new Map(existingRepos.map((r) => [r?.fullName, r]));
  const repos = [];
  
  for (const config of reposConfig) {
    console.log(`Fetching ${config.owner}/${config.repo}...`);
    let repoData;
    try {
      repoData = await fetchRepoDataWithRetries(config.owner, config.repo);
    } catch (error) {
      console.error(`Error fetching ${config.owner}/${config.repo}:`, error.message);
      const fullName = `${config.owner}/${config.repo}`;
      const prev = existingByFullName.get(fullName);
      repoData = prev || {
        name: config.repo,
        fullName,
        description: '',
        stars: 0,
        url: `https://github.com/${config.owner}/${config.repo}`,
        homepage: null,
        language: null,
        updatedAt: null,
        pushedAt: null,
      };
    }
    const thumbnailOverride = config.thumbnailOverride ?? config.thumbnail;
    const thumbnail = thumbnailOverride || githubOpenGraphThumbnail(config.owner, config.repo);
    repos.push({
      ...repoData,
      thumbnail
    });
    
    // Rate limit: GitHub allows 60 requests/hour for unauthenticated requests
    // Add a small delay to be safe
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  fs.writeFileSync(outputPath, JSON.stringify(repos, null, 2));
  console.log(`âœ… Generated ${repos.length} repos to ${outputPath}`);
}

build().catch(console.error);

